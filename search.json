[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Lovely ctypes",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "Lovely ctypes"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "Lovely ctypes",
    "section": "Developer Guide",
    "text": "Developer Guide\nIf you are new to using nbdev here are some useful pointers to get you started.\n\nInstall pretty_ctypes in Development mode\n# make sure pretty_ctypes package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to pretty_ctypes\n$ nbdev_prepare",
    "crumbs": [
      "Lovely ctypes"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "Lovely ctypes",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/xl0/pretty-ctypes.git\nor from conda\n$ conda install -c xl0 pretty_ctypes\nor from pypi\n$ pip install pretty_ctypes\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "Lovely ctypes"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "Lovely ctypes",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2",
    "crumbs": [
      "Lovely ctypes"
    ]
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utils (internal)",
    "section": "",
    "text": "source\n\nbatched\n\n batched (lst, n)\n\n\nbatched(list(range(11)), 3)\n\n[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10]]\n\n\n\nsource\n\n\ncolored\n\n colored (st, color:None|str|tuple[str|None,str|None])\n\n\nsource\n\n\nansicolor\n\n ansicolor (color:str, background=False)\n\n\nprint(f\"{colored(\"Hello\", \"BLUE\")} {colored(\"World\", (\"red\", \"green\"))} {colored(\"!\", (None, \"red\"))}\")\n\nHello World !",
    "crumbs": [
      "Utils (internal)"
    ]
  },
  {
    "objectID": "hexdump.html",
    "href": "hexdump.html",
    "title": "Hexdump and Hexdiff",
    "section": "",
    "text": "source\n\nhexdump_line\n\n hexdump_line (chunk, bits, ascii=None, width=128, highlight=None)\n\n\nprint(hexdump_line(range(16), 8))\n\n00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\n\n\n\nprint(hexdump_line(range(0x12345678, 0x12345678+4), 32, ascii=True))\n\n12345678 12345679  1234567A 1234567B  |.4Vx.4Vy.4Vz.4V{|\n\n\n\nprint(hexdump_line(range(0x12345678, 0x12345678+4), 32, ascii=True, highlight=[\"red\", \"green\", \"BLACK\", (None, \"blue\")]))\n\n12345678 12345679  1234567A 1234567B  |.4Vx.4Vy.4Vz.4V{|\n\n\n\nprint(hexdump_line(range(32), 8, ascii=True, width=128))\n\n00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F  |................................|\n\n\n\nsource\n\n\nhexdump\n\n hexdump (data, bits, highlight=None, ascii=None, width=128)\n\n\nprint(hexdump(list(range(64)), 8, highlight=[\"BLACK\", None, \"red\", \"RED\"]))\n\n00: 00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\n10: 10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F  |................|\n20: 20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F  | !\"#$%&'()*+,-./|\n30: 30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  |0123456789:;&lt;=&gt;?|\n\n\n\nprint(hexdump(range(48, 64), 32, ascii=True, highlight=[\"BLACK\", None, \"red\", \"RED\"]*2))\n\n00: 00000030 00000031  00000032 00000033  |...0...1...2...3|\n10: 00000034 00000035  00000036 00000037  |...4...5...6...7|\n20: 00000038 00000039  0000003A 0000003B  |...8...9...:...;|\n30: 0000003C 0000003D  0000003E 0000003F  |...&lt;...=...&gt;...?|\n\n\n\ndata = list(range(8)) * 8\nprint(hexdump(data, bits=8, highlight=[ \"BLACK\" if d==0 else None for d in data] ))\n\n00: 00 01 02 03 04 05 06 07  00 01 02 03 04 05 06 07  |................|\n10: 00 01 02 03 04 05 06 07  00 01 02 03 04 05 06 07  |................|\n20: 00 01 02 03 04 05 06 07  00 01 02 03 04 05 06 07  |................|\n30: 00 01 02 03 04 05 06 07  00 01 02 03 04 05 06 07  |................|\n\n\n\nsource\n\n\nhexdiff\n\n hexdiff (data1, data2, bits, ascii=None, width=128)\n\n*Compare two arrays side by side in hexdump format, highlighting differences in CYAN color.\nArgs: data1: First array to compare data2: Second array to compare bits: Number of bits per element (8, 16, 32, etc.) ascii: Whether to show ASCII representation (default: True for 8-bit, False otherwise) width: Width of each line in bits (default: 128)\nReturns: String with the side-by-side hexdump comparison*\n\ndata1 = list(range(32)) + [32, 33, 34, 35] + list(range(40, 64))\ndata2 = list(range(32)) + [1, 2, 3, 4]     + list(range(40, 60)) + [1,2,3,4,64, 65]\n\nprint(hexdiff(data1, data2, 8))\n\n00: 00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|    00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  |................|\n10: 10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F  |................|    10 11 12 13 14 15 16 17  18 19 1A 1B 1C 1D 1E 1F  |................|\n20: 20 21 22 23 28 29 2A 2B  2C 2D 2E 2F 30 31 32 33  | !\"#()*+,-./0123| =&gt; 01 02 03 04 28 29 2A 2B  2C 2D 2E 2F 30 31 32 33  |....()*+,-./0123|\n30: 34 35 36 37 38 39 3A 3B  3C 3D 3E 3F              |456789:;&lt;=&gt;?|     =&gt; 34 35 36 37 38 39 3A 3B  01 02 03 04 40 41        |456789:;....@A|  \n\n\n\nsource\n\n\nHexIntArray\n\n HexIntArray (data=None, bits=32, signed=False)\n\nInitialize self. See help(type(self)) for accurate signature.\n\na = HexIntArray([0x12345678, 0x9ABCDEF0, 0, 1], bits=32, signed=False)\nprint(a.hexdump(ascii=True))\n\n0: 12345678 9ABCDEF0  00000000 00000001  |.4Vx............|\n\n\n\na = (ctypes.c_uint16 * 64)(*range(64))\nprint(HexIntArray.from_ctypes(a).hexdump(ascii=True))\n\n00: 0000 0001 0002 0003  0004 0005 0006 0007  |................|\n10: 0008 0009 000A 000B  000C 000D 000E 000F  |................|\n20: 0010 0011 0012 0013  0014 0015 0016 0017  |................|\n30: 0018 0019 001A 001B  001C 001D 001E 001F  |................|\n40: 0020 0021 0022 0023  0024 0025 0026 0027  |. .!.\".#.$.%.&.'|\n50: 0028 0029 002A 002B  002C 002D 002E 002F  |.(.).*.+.,.-.../|\n60: 0030 0031 0032 0033  0034 0035 0036 0037  |.0.1.2.3.4.5.6.7|\n70: 0038 0039 003A 003B  003C 003D 003E 003F  |.8.9.:.;.&lt;.=.&gt;.?|\n\n\n\na = (ctypes.c_uint8 * 64)(*range(32, 96))\nprint(ah:=HexIntArray.from_ctypes(a).hexdump())\n\n00: 20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F  | !\"#$%&'()*+,-./|\n10: 30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  |0123456789:;&lt;=&gt;?|\n20: 40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  |@ABCDEFGHIJKLMNO|\n30: 50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  |PQRSTUVWXYZ[\\]^_|\n\n\n\nb = (ctypes.c_uint8 * 60).from_buffer_copy(a)\nb[17:24] = (ctypes.c_uint8 * 7)(0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77)\nprint(bh:=HexIntArray.from_ctypes(b).hexdump())\n\n00: 20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F  | !\"#$%&'()*+,-./|\n10: 30 11 22 33 44 55 66 77  38 39 3A 3B 3C 3D 3E 3F  |0.\"3DUfw89:;&lt;=&gt;?|\n20: 40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  |@ABCDEFGHIJKLMNO|\n30: 50 51 52 53 54 55 56 57  58 59 5A 5B              |PQRSTUVWXYZ[|    \n\n\n\nah = HexIntArray.from_ctypes(a)\nbh = HexIntArray.from_ctypes(b)\nprint(ah.diff(bh))\n\n00: 20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F  | !\"#$%&'()*+,-./|    20 21 22 23 24 25 26 27  28 29 2A 2B 2C 2D 2E 2F  | !\"#$%&'()*+,-./|\n10: 30 31 32 33 34 35 36 37  38 39 3A 3B 3C 3D 3E 3F  |0123456789:;&lt;=&gt;?| =&gt; 30 11 22 33 44 55 66 77  38 39 3A 3B 3C 3D 3E 3F  |0.\"3DUfw89:;&lt;=&gt;?|\n20: 40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  |@ABCDEFGHIJKLMNO|    40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F  |@ABCDEFGHIJKLMNO|\n30: 50 51 52 53 54 55 56 57  58 59 5A 5B 5C 5D 5E 5F  |PQRSTUVWXYZ[\\]^_| =&gt; 50 51 52 53 54 55 56 57  58 59 5A 5B              |PQRSTUVWXYZ[|",
    "crumbs": [
      "Hexdump and Hexdiff"
    ]
  },
  {
    "objectID": "hexint.html",
    "href": "hexint.html",
    "title": "HexInt",
    "section": "",
    "text": "Display ints of any any size as hex\n\nsource\n\nhexint\n\n hexint (value, bits)\n\nReturns the value as a hex string (with leading 0s, without 0x prefix)\n\nhexint(123, 8), hexint(-123, 8), hexint(123, 32), hexint(-123, 128), hexint(-1, 256), hexint(0x1234567890abcdef, 64)\n\n('7B',\n '85',\n '0000007B',\n 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF85',\n 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF',\n '1234567890ABCDEF')\n\n\nAnd as ascii\n\nsource\n\n\nasciiint\n\n asciiint (value:int, bits:int=8)\n\n\nasciiint(0x48656c6c6f20576f726c64, 128), asciiint(0x1234567890abcdef, 64), asciiint(70, 8), asciiint(-123, 64)\n\n('.....Hello World', '.4Vx....', 'F', '........')\n\n\nA class allows us to pack the value and the bits information together,\n\nsource\n\n\nHexInt\n\n HexInt (value:int|None, bits:int=32, signed:bool=False)\n\n*int([x]) -&gt; integer int(x, base=10) -&gt; integer\nConvert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero.\nIf x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by ‘+’ or ‘-’ and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. &gt;&gt;&gt; int(‘0b100’, base=0) 4*\n\nHexInt(123, bits=8)\n\n0x7B\n\n\n\nHexInt(-123, bits=8, signed=True)\n\n0x85 (-123)\n\n\n\nHexInt(0x1234567890abcdef, bits=64).ascii()\n\n'.4Vx....'\n\n\n\nHexInt(-123456789013443242, bits=64, signed=True)\n\n0xFE4964B459BE4D56 (-123456789013443242)\n\n\n\nHexInt.from_ctype(ctypes.c_int64(-123456789013443242))\n\n0xFE4964B459BE4D56 (-123456789013443242)\n\n\nThis is useful for ctypes enum members\n\nsource\n\n\nmake_named_int\n\n make_named_int (name, val)\n\n\nsource\n\n\nNamedInt\n\n NamedInt (val)\n\n*int([x]) -&gt; integer int(x, base=10) -&gt; integer\nConvert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero.\nIf x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by ‘+’ or ‘-’ and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal. &gt;&gt;&gt; int(‘0b100’, base=0) 4*\n\nmake_named_int(\"TEST\", 123)\n\nTEST(123)\n\n\n\nmake_named_int(\"TEST\", HexInt(123, bits=8, signed=True))\n\nTEST(0x7B)",
    "crumbs": [
      "HexInt"
    ]
  }
]
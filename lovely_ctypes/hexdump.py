"""Converting bytes to characters"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_hexdump.ipynb.

# %% auto 0
__all__ = ['hexdump_line', 'hexdump', 'hexdiff', 'HexIntArray']

# %% ../nbs/01_hexdump.ipynb 3
import ctypes
from .hexint import hexint, asciiint, ctypes_int_types, ctypes_signed_types
from .utils import colored, batched

# %% ../nbs/01_hexdump.ipynb 4
def hexdump_line(chunk, bits, ascii=None, width=128, highlight=None):
  if ascii is None: ascii = True if bits == 8 else False
  if highlight is None: highlight = [None]*len(chunk)
  highlight = highlight + ([None]*(len(chunk)-len(highlight)))

  # Group the output into 64-bit groups if it's long: 40 41 42 43 44 45 46 47  48 49 4A 4B 4C 4D 4E 4F
  sub_width = 64 if width >= 128 else width
  res = "  ".join(" ".join(colored(hexint(d, bits), hl) for d, hl in sub)
                  for sub in batched(list(zip(chunk, highlight)), sub_width // bits))


  # Pad with spaces in case this needs to be align
  res += ((" " * (bits // 4)) + " ") * (width//bits - (len(chunk))) + (" " if len(chunk) < sub_width//bits else "")
  if ascii:
    res += f"  |{''.join(colored(asciiint(d, bits), hl) for d, hl in zip(chunk, highlight, strict=False))}|" + (" " * (width//bits - (len(chunk))))
  return res

# %% ../nbs/01_hexdump.ipynb 9
def hexdump(data, bits, highlight=None, ascii=None, width=128):
    width = max(width, bits)
    if highlight is None: highlight = []

    if len(highlight) < len(data):
        highlight = highlight + ([None] * (len(data) - len(highlight)))

    chunks = zip(batched(data, width // bits), batched(highlight, width // bits))
    lines = [hexdump_line(d, bits=bits, ascii=ascii, width=width, highlight=h) for d, h in chunks]

    addr_digits = len(f"{(len(lines) - 1)*(width//8):X}")
    return "\n".join(f"{(i*width)//8:0{addr_digits}X}: {lines[i]}" for i in range(len(lines)))

# %% ../nbs/01_hexdump.ipynb 13
def hexdiff(data1, data2, bits, ascii=None, width=128):
    """
    Compare two arrays side by side in hexdump format, highlighting differences in CYAN color.

    Args:
        data1: First array to compare
        data2: Second array to compare
        bits: Number of bits per element (8, 16, 32, etc.)
        ascii: Whether to show ASCII representation (default: True for 8-bit, False otherwise)
        width: Width of each line in bits (default: 128)

    Returns:
        String with the side-by-side hexdump comparison
    """
    width = max(width, bits)
    if ascii is None: ascii = True if bits == 8 else False

    elems_per_line = width // bits

    lines_data1 = (len(data1) + elems_per_line - 1) // elems_per_line
    lines_data2 = (len(data2) + elems_per_line - 1) // elems_per_line
    total_lines = max(lines_data1, lines_data2)

    addr_digits = len(f"{(total_lines - 1)*(width//8):X}")
    result = []

    for i in range(total_lines):
        start_idx = i * elems_per_line
        end_idx = min(start_idx + elems_per_line, len(data1))
        end_idx2 = min(start_idx + elems_per_line, len(data2))

        chunk1 = data1[start_idx:end_idx] if start_idx < len(data1) else []
        chunk2 = data2[start_idx:end_idx2] if start_idx < len(data2) else []

        highlight = []

        for j in range(max(len(chunk1), len(chunk2))):
            if j >= len(chunk1) or j >= len(chunk2): highlight.append("yellow")
            elif chunk1[j] != chunk2[j]:             highlight.append("CYAN")
            elif chunk1[j] == 0:                     highlight.append("BLACK")
            else:                                    highlight.append(None)

        line1 = hexdump_line(chunk1, bits, ascii=ascii, width=width, highlight=highlight) if chunk1 else ""
        line2 = hexdump_line(chunk2, bits, ascii=ascii, width=width, highlight=highlight) if chunk2 else ""

        sep = colored("=>", "CYAN") if chunk1 != chunk2 else "  "
        addr = f"{i*(width//8):0{addr_digits}X}"

        result.append(f"{addr}: {line1} {sep} {line2}")

    return "\n".join(result)

# %% ../nbs/01_hexdump.ipynb 15
class HexIntArray():
    def __init__(self, data=None, bits=32, signed=False):
        assert bits >= 4, f"data.bits must be at least 4, got {bits}"
        # assert bits <= 64, f"data.bits must not exceed 64, got {bits}"
        self.bits, self.signed = bits, signed
        self.data = list(data) if data is not None else []

    def __len__(self): return len(self.data)
    def __getitem__(self, key): return self.data[key]
    def __iter__(self): return iter(self.data)


    @classmethod
    def from_ctypes(cls, ct):
        assert isinstance(ct, ctypes.Array), f"Expected ct to be ctypes.Array, got {type(ct)}"
        assert ct._type_ in ctypes_int_types, f"Expected ct._type to be in {ctypes_int_types}, got {ct._type_}"
        assert len(ct), f"Expected ct to be non-empty"
        bits = 1 if ct._type_ == ctypes.c_bool else ctypes.sizeof(ct._type_)*8
        return cls(ct, bits, ct._type_ in ctypes_signed_types)

    def hexdump(self, ascii=None, width=128):
        # validate_hexdump_input(data)
        # bits = data[0].bits
        width = max(width, self.bits)
        hl = ["BLACK" if d==0 else None for d in self.data]
        chunks = list(zip(batched(self.data, width // self.bits), batched(hl, width // self.bits)))
        lines = [ hexdump_line(c, bits=self.bits, ascii=ascii, width=width, highlight=h) for c, h in chunks]
        addr_digits = len(f"{(len(lines) - 1)*(width//8):X}")
        return "\n".join(f"{(i*width)//8:0{addr_digits}X}: {lines[i]}" for i in range(len(lines)))

    def diff(self, other, ascii=None, width=128):
        assert self.bits == other.bits, f"Expected self.bits to be equal to other.bits, got {self.bits} and {other.bits}"
        return hexdiff(self.data, other.data, bits=self.bits, ascii=ascii, width=width)
